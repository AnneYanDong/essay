<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>事件机制</title>
</head>
<body>
	<h2>JavaScript事件机制：事件绑定、事件监听、事件委托（事件代理）</h2>
	<h3>1、事件绑定</h3>
	<p>
		我们一般会对用户的操作（点击事件，鼠标事件，键盘事件等）做出响应，
		也就是要对DOM元素绑定事件处理函数，就是处理用户操作的函数，不同得到操作对应不同的名称。
	</p>
	<p>
		<h4>绑定事件的方法有三种：</h4>
		<ol>
			<li>
				在DOM元素中直接绑定:
				<pre>
					<!-- <input id="btn" type="button" value="click me" onclick="hello()"> -->
					function hello() {
						alert("hello world!");
					}
				</pre>
			</li>
			<li>
				在JavaScript代码中绑定:
				<pre>
					document.getElementById('btn').onclick = function() {
						alert('JavaSript代码中绑定事件！');
					}
				</pre>
				在JavaScript代码中绑定事件，是js代码与HTML标签结构分离，文档结构清晰，便于管理和开发
			</li>
			<li>
				<pre>
				绑定事件监听函数:使用addEventListener()或attachEvent()【IE8以前的机制】来绑定事件监听函数
				关于事件监听，W3C规范中定义了3个事件阶段：捕获阶段、目标阶段、冒泡阶段

				W3C规范的语法： element.addEventListener(event,function,useCapture)
				event: (必须)事件名，支持所有DOM事件。
				function: (必须)指定事件触发时执行的函数。
				useCapture: (可选)指定事件是否在捕获或者冒泡阶段阶段执行。true:捕获；false:冒泡。默认false
				// IE8以下不支持
				document.getElementById('btn').addEventListener("click",hello);
				function hello() {
					alert("addEventListener事件监听！");
				}

				IE标准语法：element.attachEvent(event,function)
				event: (必须)事件类型，需加“on”,比如onclick
				function: (必须)指定事件触发时要执行的函数。
				// IE8以下
				document.getElementById('btn2').attachEvent('onclick',hello);
				function hello() {
					alert("attachEvent事件监听！");
				}

				封装事件监听：
				function eventHandler(ele,type,fn) {
					if (ele.addEventListener) {
						ele.addEventListener(type,fn);
					} else {
						ele.attachEvent("on"+type,fn);
					}
				}
				eventHandler(btn5,"click",hello3);
				function hello3() {
					alert("hello 3");
				}
				</pre>
				<pre>
					<h4>事件监听的优点：</h4>
					<ol>
						<li>同一元素可以绑定多个事件，一般的事件绑定只执行最后绑定的事件，但是通过事件监听绑定的事件都会执行</li>
						<pre>
							//一般的事件绑定
							var btn4 = document.getElementById('btn4');
							btn4.onclick = function() {
								alert("hello 1"); //不执行
							}
							btn4.onclick = function() {
								alert("hello 2"); //执行
							}
						</pre>
						<li>既然事件监听可以让同一元素绑定多个事件，那么可以用removeEventListener移除某个事件处理程序</li>
						<pre>
							//事件监听绑定
							var btn5 = document.getElementById('btn5');
							btn5.addEventListener('click',hello1);
							btn5.addEventListener('click',hello2);
							function hello1() {
								alert("hello 1"); //执行了
							}
							function hello2() {
								alert("hello 2"); //执行了
							}

							//解除相应的绑定事件
							btn5.removeEventListener('click',hello2); //btn5就只执行了hello 1这个函数
						</pre>
					</ol>
				</pre>
			</li>
		</ol>
	</p>
	<h3>2、事件委托</h3>
	<p>事件委托是利用冒泡的原理，把事件加到父元素或者祖先元素上，触发执行效果</p>
	<pre>
	//事件委托
	var btn6 = document.getElementById('btn6');
	//在根元素绑定的事件
	document.onclick = function(event) {
		var event = event || window.event;
		var target = event.target || event.srcElement;
		if (target == btn6) {
			alert(btn6.value);
		}
	</pre>
	<h4>事件委托的优点：</h4>
	<ol>
		<li>1、提高JavaScript性能。事件委托可以显著的提高事件的处理速度，减少内存的占用。
		<pre>
			var item1 = document.getElementById('item1');
			var item2 = document.getElementById('item2');
			var item3 = document.getElementById('item3');
			//事件绑定
			// console.time(1);
			// item1.onclick = function hello1() {
			// 	alert("hello item1");
			// }
			// item2.onclick = function hello2() {
			// 	alert("hello item2");
			// }
			// item3.onclick = function hello3() {
			// 	alert("hello item3");
			// }
			// console.timeEnd(1);
			//事件委托,将事件绑定在document上
			console.time(2);
			eventHandler(document,"click",function(event) {
				var target = event.target;
				console.log("target->",event.target);
				if(target == item1) {
					alert("hello item1");
				} else if (target == item2) {
					alert("hello item2");
				} else if (target == item3) {
					alert("hello item3");
				} else {
					return;
				}
			})
			console.timeEnd(2);
		</pre>
		</li>
		<li>2、动态的添加DOM元素，不需要因为元素得到改动而修改事件绑定
		<pre>
			//传统写法，虽然动态添加了item4及其文本，但是点击item4没有click事件发生,说明传统的事件绑定无法对动态添加的元素而动态的添加事件
			// var items = document.getElementsByTagName('li');
			// for(var i = 0,len = items.length; i < len; i++) {
			// 	(function(i) {
			// 		items[i].onclick = function() {
			// 			alert(items[i].innerHTML);
			// 		}
			// 	})(i);
			// }
			//事件委托,这个时候点击item4有事件响应。说明事件委托可以为新添加的元素动态的添加事件
			document.addEventListener("click",function(event){
				var target = event.target;
				if (target.nodeName == "LI") {
					alert(target.innerHTML);
				}
			})
			var node = document.createElement('li');
			var textNode = document.createTextNode("item4:click me");
			node.appendChild(textNode);
			list.appendChild(node);
		</pre>
		</li>
	</ol>

	<input type="button" value="普通事件绑定" id="btn4">
	<input type="button" value="事件监听绑定" id="btn5">
	<input type="button" value="事件委托" id="btn6">

	<ul id="list">
		<li id="item1">item1:click me</li>
		<li id="item2">item2:click me</li>
		<li id="item3">item3:click me</li>
	</ul>
	<script>
		// function hello() {
		// 	alert("hello world!");
		// }
		// document.getElementById('btn').onclick = function() {
		// 	alert('JavaSript代码中绑定事件！');
		// }
		// IE8以下不支持
		// document.getElementById('btn').addEventListener("click",hello);
		// function hello() {
		// 	alert("addEventListener事件监听！");
		// }

		// IE8以下
		// document.getElementById('btn2').attachEvent('onclick',hello);
		// function hello() {
		// 	alert("attachEvent事件监听！");
		// }
		//一般的事件绑定
		var btn4 = document.getElementById('btn4');
		btn4.onclick = function() {
			alert("hello 1"); //不执行
		}
		btn4.onclick = function() {
			alert("hello 2"); //执行
		}
		//事件监听绑定
		var btn5 = document.getElementById('btn5');
		btn5.addEventListener('click',hello1);
		btn5.addEventListener('click',hello2);
		function hello1() {
			alert("hello 1"); //执行了
		}
		function hello2() {
			alert("hello 2"); //执行了
		}
		//解除相应的绑定事件
		btn5.removeEventListener('click',hello2); //btn5就只执行了hello 1这个函数

		//封装事件监听
		function eventHandler(ele,type,fn) {
			if (ele.addEventListener) {
				ele.addEventListener(type,fn);
			} else {
				ele.attachEvent("on"+type,fn);
			}
		}
		eventHandler(btn5,"click",hello3);
		function hello3() {
			alert("hello 3");
		}

		//事件委托
		var btn6 = document.getElementById('btn6');
		//在根元素绑定的事件
		document.onclick = function(event) {
			var event = event || window.event;
			var target = event.target || event.srcElement;
			if (target == btn6) {
				alert(btn6.value);
			}
		}

		var list = document.getElementById('list');
		var item1 = document.getElementById('item1');
		var item2 = document.getElementById('item2');
		var item3 = document.getElementById('item3');
		//事件绑定
		// console.time(1);
		// item1.onclick = function hello1() {
		// 	alert("hello item1");
		// }
		// item2.onclick = function hello2() {
		// 	alert("hello item2");
		// }
		// item3.onclick = function hello3() {
		// 	alert("hello item3");
		// }
		// console.timeEnd(1);
		//事件委托,将事件绑定在父元素list上
		// console.time(2);
		// eventHandler(list,"click",function(event) {
		// 	var target = event.target;
		// 	console.log("target->",event.target);
		// 	if(target == item1) {
		// 		alert("hello item1");
		// 	} else if (target == item2) {
		// 		alert("hello item2");
		// 	} else if (target == item3) {
		// 		alert("hello item3");
		// 	} else {
		// 		return;
		// 	}
		// })
		// console.timeEnd(2);
		//传统写法，虽然动态添加了item4及其文本，但是点击item4没有click事件发生,说明传统的事件绑定无法对动态添加的元素而动态的添加事件
		// var items = document.getElementsByTagName('li');
		// for(var i = 0,len = items.length; i < len; i++) {
		// 	(function(i) {
		// 		items[i].onclick = function() {
		// 			alert(items[i].innerHTML);
		// 		}
		// 	})(i);
		// }
		//事件委托,这个时候点击item4有事件响应。说明事件委托可以为新添加的元素动态的添加事件
		document.addEventListener("click",function(event){
			var target = event.target;
			if (target.nodeName == "LI") {
				alert(target.innerHTML);
			}
		})
		var node = document.createElement('li');
		var textNode = document.createTextNode("item4:click me");
		node.appendChild(textNode);
		list.appendChild(node);

	</script>
</body>
</html>