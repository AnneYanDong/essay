<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title></title>
</head>
<body>
	<h2>DOM操作的昂贵在于：</h2>
	<p>1、访问DOM元素</p>
	<p>2、修改DOM引起的重绘重排</p>
	<h3>什么是重绘重排？</h3>
	<p>首先理解一下文档的加载过程：</p>
	<p>在浏览器下载完页面中的所有组件-HTML标记、javascript、css、图片之后会解析生成两个内部数据结构--DOM树和渲染树。</p>
	<p>在文档初次加载时，浏览器引擎通过解析HTML文档构建一棵DOM树，之后根据DOM元素的几何属性（宽或高）构建一棵用于渲染的渲染树。</p>
	<p>渲染树中的节点被称为“帧”或“盒”，符合CSS盒模型的定义，可理解为（包括理解页面元素）一个具有大小，填充，边距，边框和位置的盒子。</p>
	<p>由于隐藏元素不需要显示，渲染树中并不包含DOM树种隐藏的元素（知道这点有用）</p>
	<p>当渲染树构建完成，浏览器把每一个元素放到正确的位置上，然后根据每一个元素的其他样式，绘制页面。</p>

	<p>由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常需要花3倍于同等元素的时间。这也是我们为什么要避免使用table布局的一个原因</p>

	<p>重绘：是一个元素外观的改变所触发的浏览器的行为，例如改变visibility,outline,背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。</p>

	<p>重排：当DOM的变化影响了元素的几何属性（宽或高），浏览器需要重新计算元素的几何属性，同样，其他元素的几何属性和位置也因此会受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程叫重排。重排一定伴随着重绘。</p>
	<p>
		<h2>触发重排的操作有：</h2>
		<div>
			<h3>1、修改DOM元素的几何属性</h3>
			<p>修改这个几何属性主要包括修改元素的<b>大小</b>、<b>位置</b>、<b>内容（内容一般只有重绘，但是内容的改变可能导致元素大小的改变）</b></p>
		</div>
		<div>
			<h3>2、DOM树结构发生变化</h3>
			<p>当DOM树结构发生变化时，如节点的添加删除、移动等，也会触发重排。浏览器引擎布局的过程，类似于树的前序遍历，从上到下从左到右的过程。通常在这个过程中，当前元素不会影响前面已经遍历过的元素。所以，如果在body前面插入一个元素，会导致整个文档的重新渲染，而在其后面插入元素，则不会影响到前面的元素。</p>
		</div>
		<div><h3>3、浏览器大小的改变</h3></div>
		<div>
			<h3>4、渲染树变化的排列和更新</h3>
			<p>比如有代码：
				<code>
				<pre>
				console.time(5);
				var ele = document.getElementById('div1');
				ele.style.borderLeft = '1px';
				ele.style.borderRight = '2px';
				// var _top = ele.offsetTop; //刷新队列
				ele.style.padding = '5px';
				console.timeEnd(5);

				console.time(6);
				var ele = document.getElementById('div1');
				ele.style.borderLeft = '1px';
				ele.style.borderRight = '2px';
				var _top = ele.offsetTop; //刷新队列
				ele.style.padding = '5px';
				console.timeEnd(6);
				</pre>
				</code>
				<span>注释掉的代码的执行时间比没有注释掉的代码执行时间要少，而且执行的次数越多，时间差越大。</span>
				<p>第一段代码：三行代码，有三次修改了元素的几何属性，按道理说浏览器应该会发生三次重排。但是浏览器并不会这么笨，它自己本身也是有做优化的。它会把三次修改“保存”起来（大多浏览器通过队列话修改并批量执行来优化重排过程，也有设置时间片段的），一次完成！</p>
				<p>然而，如果你在三行代码中，获取以下DOM布局信息的属性，如上面注释的那一行，如果取消注释会导致（2+3）、（5）两次重排</p>
				<p>获取关于DOM布局信息的属性：</p>
				<ol>
					<li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li>
					<li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li>
					<li>clientTop、clientLeft、clientWidth、clientHeight</li>
					<li>getComputedStyle()（currentStyle in IE）</li>
				</ol>
			</p>
		</div>
	</p>
	<h2>应对重排重绘的方法：</h2>
	<p>1、合并多次操作，如上面的操作
		<code>ele.style.cssText = 'border-left: 1px;border-right: 2px; padding: 5px;'</code>
	</p>
	<p>2、将需要多次重排的元素，position属性设置为absolute或fixed，这样元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设定为绝对定位。</p>
	<p>3、由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。因此，如果要对一个元素进行复杂的操作时，可以先将其隐藏，然后操作完成以后再显示。这样就只在隐藏和显示时触发2次重排。但是这可能导致浏览器的闪烁。</p>
	<p>4、在内存中多次操作节点，完成后再添加到文档中去（可使用fragment元素）。例如要异步获取表格数据，渲染到页面。可以先取得数据后在内存中构建整个表格的html片段，再一次性添加到文档中去，而不是循环添加每一行。</p>
	<code>
		<pre>
		//fragment片段优化
		var fragment = document.createDocumentFragment(); //未使用的虚拟节点

		var li = document.createElement('li');
		li.innerHTML = 'apple';
		fragment.appendChild('li');


		var li = document.createElement('li');
		li.innerHTML = 'watermelon';
		fragment.appendChild('li');

		document.getElementById('fruit').appendChild(fragment);
		</pre>
	</code>

	<div id="div1">11</div>
	<ul id="fruit">
		<li>apple</li>
		<li>orange</li>
		<li>banana</li>
	</ul>
<script>
	// 方法一：减少DOM访问
	console.time(1);
	var str = '';
	for(var i = 0; i < 5; i++) {
		document.getElementById("div1").innerHTML += 'a'; //这是每循环一次就要访问一次元素div1
	}
	console.timeEnd(1);

	console.time(2);
	var str = '';
	for(var i = 0; i < 5; i++) {
		str += 'a';
	}
	document.getElementById("div1").innerHTML = str; //减少了DOM操作
	console.timeEnd(2);
	// 执行结果：
	// 1: 2.612ms
 //    2: 0.057ms
	// 明显第二种时间更短，执行更快

	// HTML集合以及遍历DOM的时候
	var lis = document.getElementsByTagName('li');
	var peach = document.createElement('li');
	peach.innerHTML = 'peach';
	document.getElementById('fruit').appendChild(peach);

	console.log(lis.length);
	//这个值是实时更新的，也就是HTML集合是实时更新的，导致HTML集合在读取length的时候消耗太大，解决这个问题不难，就是在遍历集合的时候，把length值缓存一下就可以

	console.time(3);
	var lis1 = document.getElementsByTagName('li');
	var str1 = '';
	for(var i = 0; i < lis.length; i++) {
		str1 += lis1[i].innerHTML;
	}
	console.timeEnd(3);

	console.time(4);
	var lis2 = document.getElementsByTagName('li');
	var str2 = '';
	for(var i = 0, len = lis2.length; i < len; i++) {
		str2 += lis2[i].innerHTML;
	}
	console.timeEnd(4);
	// 3: 0.142ms
	// 4: 0.061ms

	// 二：重绘重排
	console.time(5);
	var ele = document.getElementById('div1');
	ele.style.borderLeft = '1px';
	ele.style.borderRight = '2px';
	// var _top = ele.offsetTop; //刷新队列
	ele.style.padding = '5px';
	console.timeEnd(5);

	console.time(6);
	var ele = document.getElementById('div1');
	ele.style.borderLeft = '1px';
	ele.style.borderRight = '2px';
	var _top = ele.offsetTop; //刷新队列
	ele.style.padding = '5px';
	console.timeEnd(6);

	//fragment片段优化
	var fragment = document.createDocumentFragment(); //未使用的虚拟节点

	var li = document.createElement('li');
	li.innerHTML = 'apple';
	fragment.appendChild('li');


	var li = document.createElement('li');
	li.innerHTML = 'watermelon';
	fragment.appendChild('li');

	document.getElementById('fruit').appendChild(fragment);
</script>
</body>
</html>